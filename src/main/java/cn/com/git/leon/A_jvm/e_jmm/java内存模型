1、Java所有变量都存储在主内存中
2、每个线程都有自己独立的工作内存，里面保存该线程的使用到的变量副本（该副本就是主内存中该变量的一份拷贝）

1、线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接在主内存中读写
2、不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。
线程1对共享变量的修改，要想被线程2及时看到，必须经过如下2个过程：
1、把工作内存1中更新过的共享变量刷新到主内存中
2、将主内存中最新的共享变量的值更新到工作内存2中

Synchronized：保证可见性和原子性
线程在加锁时，先清空工作内存→在主内存中拷贝最新变量的副本到工作内存
→执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。

Volatile：保证可见性，但不保证操作的原子性
Volatile实现内存可见性是通过store和load指令完成的；也就是对volatile变量执行写操作时，会在写操作后加入一条store指令，即强迫线程将最新的值刷新到主内存中；
而在读操作时，会加入一条load指令，即强迫从主内存中读入变量的值。但volatile不保证volatile变量的原子性，例如：
i++分为两步 读取i的值 加1
线程1读取i的值为0 cpu分配算法让线程2执行线程2读取i的值为0 +1 为1 线程1执行+1还是为1